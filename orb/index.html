<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<title>Liten Orb Puzzle</title>
<style>
    /* Definer fargevariabler for lys modus */
    :root {
        /* Just√©r disse variablene for √• endre fargene i lys modus */
        --bg-color: #ffffff;      /* bakgrunnsfarge for kroppen */
        --text-color: #000000;    /* tekstfarge */
        --empty-color: #dddddd;   /* farge for tomme celler */
        --player-color: #1a44cfff;  /* farge for spilleren */
        --goal-color: #00cc44;    /* farge for m√•let */
        --block-color: #000000;   /* farge for sorte blokker */
        --hazard-color: #ff2222;  /* farge for r√∏de feller */
        --status-color: #555555;  /* farge for statusmeldingene */
        --bonus-color: #ffd700;   /* farge for gule bonuskuler */
    }
    /* Overstyr variablene i m√∏rk modus */
    body.dark-mode {
        /* Variabler for m√∏rk modus - endre disse for √• justere temaet */
        --bg-color: #1a1a1a;
        --text-color: #f0f0f0;
        --empty-color: #333333;
        --player-color: #e6e6e6;
        --goal-color: #33aa55;
        --block-color: #000000;
        --hazard-color: #cc4444;
        --status-color: #bbbbbb;
        --bonus-color: #e6c200;
    }
    html, body {
        width: 100%;
        height: 100%;
        margin: 0;
        overflow: hidden; /* unng√• scrollbars */
    }
    body {
        font-family: Arial, sans-serif;
        /* gj√∏r at spillomr√•det alltid er sentrert p√• skjermen */
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        background-color: var(--bg-color);
        color: var(--text-color);
    }

    /* Gj√∏r tittelen mindre slik at den ikke tar opp for mye av skjermen */
    h1 {
        font-size: 1.4em;
        margin-top: 0;
        margin-bottom: 4px;
    }
    #scoreboard {
        margin: 10px;
        font-size: 1.2em;
    }
    /* gj√∏r brettet responsivt slik at det passer p√• ulike skjermer */
    #gameContainer {
        /*
         * Spillbrettets st√∏rrelse kontrolleres dynamisk i JavaScript basert p√•
         * gridWidth og gridHeight. Vi setter ikke fast width/height her, slik
         * at vi kan beregne brettets forholdstall (aspect ratio) p√• egenh√•nd.
         * Containeren er fremdeles et grid, med et lite mellomrom mellom cellene.
         */
        display: grid;
        gap: 2px;
        margin: 10px 0;
        /* La brettet sentrere seg horisontalt n√•r bredden justeres av JS */
        margin-left: auto;
        margin-right: auto;
    }
    /* hver celle fyller en br√∏kdel av brettet og holder kvadratisk form */
    .cell {
        /* cellst√∏rrelsen bestemmes av gridens rad- og kolonnefraksjoner samt containerens aspect ratio */
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
    }
    .empty {
        background-color: var(--empty-color);
    }
    .player {
        background-color: var(--player-color);
        box-shadow: 0 0 8px rgba(0,0,0,0.3);
    }
    .goal {
        background-color: var(--goal-color);
    }
    .block {
        background-color: var(--block-color);
    }
    .hazard {
        background-color: var(--hazard-color);
    }

    /* nye bonuskuler som gir ekstra poeng */
    .bonus {
        background-color: var(--bonus-color);
    }

    /* statusmeldingen vises mellom niv√•er og fjernes automatisk */
    /* statusmeldingen plasseres absolutt over brettet slik at den ikke p√•virker layouten */
    #statusMessage {
        position: absolute;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        width: 100%;
        text-align: center;
        font-size: 0.9em;
        color: var(--status-color);
        pointer-events: none;
    }

    /* wrapper for poeng og restart-knapp */
    #scoreWrapper {
        display: flex;
        align-items: center;
        gap: 12px;
        margin-top: 8px;
    }
    #scoreboard {
        font-size: 1em;
    }
    #restartBtn {
        background: none;
        border: 1px solid var(--text-color);
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 0.9em;
        color: var(--text-color);
        cursor: pointer;
    }

    /* kontroller for m√∏rk/lys-modus og lenke */
    #controls {
        position: absolute;
        top: 10px;
        right: 10px;
        display: flex;
        gap: 12px;
        align-items: center;
    }
    #controls button {
        background: none;
        border: none;
        font-size: 1.4em;
        cursor: pointer;
        color: var(--text-color);
    }
    #controls a {
        text-decoration: none;
        color: var(--text-color);
        font-size: 0.9em;
        border: 1px solid var(--text-color);
        padding: 4px 6px;
        border-radius: 4px;
    }

    /* Startoverlegg som dekker hele skjermen f√∏r og mellom spill */
    #startOverlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 20;
        /* Skjul overlegget som standard; vis det via JS n√•r det trengs */
        display: none;
    }
    #startContent {
        background-color: var(--bg-color);
        color: var(--text-color);
        padding: 20px 30px;
        border-radius: 8px;
        box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        text-align: center;
    }
    #startContent p {
        margin-top: 0;
        margin-bottom: 12px;
        font-size: 1em;
    }
    #startContent button {
        background: none;
        border: 1px solid var(--text-color);
        padding: 6px 12px;
        border-radius: 4px;
        font-size: 1em;
        cursor: pointer;
        color: var(--text-color);
    }

    /* Instruksjonsboks i startskjermen */
    #instructions {
        border: 1px solid var(--empty-color);
        background-color: var(--empty-color);
        color: var(--text-color);
        padding: 8px 10px;
        border-radius: 4px;
        font-size: 0.9em;
        line-height: 1.3;
        max-width: 300px;
        white-space: pre-line;
    }
</style>
</head>
<body>
<h1>Liten Orb Puzzle</h1>
<!-- wrapper for poeng, niv√• og restart-knapp -->
<div id="scoreWrapper">
  <div id="scoreboard">
    Niv√•: <span id="level">1</span> | Poeng: <span id="score">0</span> | H√∏yeste: <span id="highScore">0</span> | Tid: <span id="time">0.0</span> sek | Trekk: <span id="movesLeft">0</span>
  </div>
  <!-- Restart-knappen vises kun n√•r spilleren taper. Den flyttes ut av scoreboardet i CSS
       og vises kun n√•r gameOver = true. -->
  <button id="restartBtn" style="display:none;" title="Start spillet p√• nytt">Restart</button>
</div>
<!-- kontroller: m√∏rk/lys-modus og lenke -->
<div id="controls">
  <button id="themeToggle" title="Bytt mellom m√∏rk og lys modus">üåô</button>
  <a id="sarcasmLink" href="https://sarcasm.games" target="_blank" title="Bes√∏k sarcasm.games">sarcasm.games</a>
</div>
<!-- statusmelding for raske niv√•overganger -->
<div id="statusMessage" class="status-message"></div>
<div id="gameContainer"></div>

<!-- Start-/pauseskjerm som vises f√∏r og mellom spill. Inneholder en play-knapp og valgfri melding.  -->
<div id="startOverlay">
  <div id="startContent">
    <!-- Velkomst-/sluttmelding settes dynamisk i JS -->
    <p id="startMessage" style="font-weight:bold; font-size:1.2em; margin-bottom:8px;">Velkommen!</p>
    <!-- Instruksjonstekst som forklarer spilleregler og kontroller -->
    <div id="instructions">
      Bruk piltastene eller WASD for √• flytte den hvite kula til den gr√∏nne.<br>
      Unng√• svarte blokkeringer og r√∏de feller som avslutter spillet.<br>
      Samle gule bonuskuler for ekstra poeng.<br>
      Du har begrenset antall trekk ‚Äì planlegg ruten din!<br>
      Poengene beregnes som antall ruter p√• brettet minus tiden du bruker (i sekunder), s√• st√∏rre brett gir flere basispoeng, men jo raskere du er jo bedre. Bonuskuler gir ekstra poeng.
    </div>
    <button id="startButton" style="margin-top:12px;">Play</button>
  </div>
</div>
<script>
// Spillvariabler
// baseSize angir den ¬´kvadratiske¬ª basest√∏rrelsen p√• brettet. gridWidth og gridHeight kan
// variere fra baseSize for √• lage rektangul√¶re brett. baseSize √∏ker jevnt med niv√•et.
let baseSize = 3;
let gridWidth = 3;
let gridHeight = 3;
let board = [];
let playerPos = {x:0, y:0};
let goalPos = {x:0, y:0};
let timerInterval;
let startTime;
let score = 0;
let level = 1;
let gameOver = false;
// Antall trekk spilleren har igjen i det n√•v√¶rende niv√•et. Dette initialiseres
// i resetMoves() n√•r brettet genereres. Endre formelen i resetMoves() for √•
// justere vanskeligheten (flere eller f√¶rre trekk).
let movesLeft = 0;

// H√∏yeste poengsum lagret i localStorage. Dette oppdateres ved spillslutt hvis
// spilleren oppn√•r en ny rekord. H√∏y score vises i poengtavlen og
// oppmuntrer til √• spille √©n runde til.
let highScore = 0;

// Funksjon for √• vise start-/spillslutt-overlegget med en egendefinert melding.
function showStartOverlay(message) {
    const overlay = document.getElementById('startOverlay');
    const messageEl = document.getElementById('startMessage');
    if (messageEl) {
        messageEl.textContent = message || 'Velkommen!';
    }
    if (overlay) {
        overlay.style.display = 'flex';
    }
}

// Funksjon for √• skjule startoverlegget
function hideStartOverlay() {
    const overlay = document.getElementById('startOverlay');
    if (overlay) {
        overlay.style.display = 'none';
    }
}

// h√•ndter m√∏rk/lys-modus
function applyStoredTheme() {
    const stored = localStorage.getItem('theme');
    const isDark = stored === 'dark';
    const body = document.body;
    const toggleButton = document.getElementById('themeToggle');
    if (isDark) {
        body.classList.add('dark-mode');
    } else {
        body.classList.remove('dark-mode');
    }
    // oppdater ikon
    if (toggleButton) {
        toggleButton.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
    }
}

function toggleTheme() {
    const body = document.body;
    const isDark = body.classList.toggle('dark-mode');
    const toggleButton = document.getElementById('themeToggle');
    if (toggleButton) {
        toggleButton.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
    }
    localStorage.setItem('theme', isDark ? 'dark' : 'light');
}

// Sjekk om det finnes en sti fra spilleren til m√•let, gitt gjeldende brett
// Vi bruker bredde-f√∏rst-s√∏k (BFS) og behandler b√•de blokkeringer og feller som ugjennomtrengelige.
function hasPath() {
    const queue = [];
    // Opprett bes√∏kt-matrisen basert p√• gridHeight og gridWidth. gridHeight er antall rader,
    // gridWidth er antall kolonner.
    const visited = Array.from({ length: gridHeight }, () => Array(gridWidth).fill(false));
    queue.push({ x: playerPos.x, y: playerPos.y });
    visited[playerPos.y][playerPos.x] = true;
    const directions = [
        { dx: 1, dy: 0 },
        { dx: -1, dy: 0 },
        { dx: 0, dy: 1 },
        { dx: 0, dy: -1 },
    ];
    while (queue.length > 0) {
        const { x, y } = queue.shift();
        // hvis vi n√•r m√•let, er brettet l√∏sbart
        if (x === goalPos.x && y === goalPos.y) {
            return true;
        }
        for (const { dx, dy } of directions) {
            const nx = x + dx;
            const ny = y + dy;
            if (
                nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight &&
                !visited[ny][nx] &&
                board[ny][nx] !== 'block' &&
                board[ny][nx] !== 'hazard'
            ) {
                visited[ny][nx] = true;
                queue.push({ x: nx, y: ny });
            }
        }
    }
    return false;
}

function initBoard() {
    // Vi √∏nsker √• generere et brett som alltid kan l√∏ses.
    // Derfor fors√∏ker vi flere ganger til en gyldig sti fra spiller til m√•l finnes.
    let solvable = false;
    let attempts = 0;
    while (!solvable) {
        attempts++;
        // start med tomt brett basert p√• gridHeight og gridWidth
        board = [];
        for (let y = 0; y < gridHeight; y++) {
            board[y] = [];
            for (let x = 0; x < gridWidth; x++) {
                board[y][x] = 'empty';
            }
        }
        // plasser spilleren p√• en tilfeldig tom celle for variasjon
        // (Hvis du √∏nsker at spilleren alltid skal starte i midten, kan du endre dette.)
        let placedPlayer = false;
        while (!placedPlayer) {
            const px = Math.floor(Math.random() * gridWidth);
            const py = Math.floor(Math.random() * gridHeight);
            if (board[py][px] === 'empty') {
                playerPos = { x: px, y: py };
                board[playerPos.y][playerPos.x] = 'player';
                placedPlayer = true;
            }
        }
        // plasser m√•let p√• tilfeldig tom celle som ikke er spiller
        let placedGoal = false;
        while (!placedGoal) {
            const gx = Math.floor(Math.random() * gridWidth);
            const gy = Math.floor(Math.random() * gridHeight);
            if (board[gy][gx] === 'empty') {
                board[gy][gx] = 'goal';
                goalPos = { x: gx, y: gy };
                placedGoal = true;
            }
        }
        // beregn antall hindringer og feller basert p√• niv√• og brettst√∏rrelse
        const totalCells = gridWidth * gridHeight;
        // ********* Just√©r vanskelighetsparametre her *********
        // baseBlockPercent: andel av rutenettet som skal fylles med sorte blokker p√• niv√• 1 (0.1 = 10%).
        // baseHazardPercent: andel av rutenettet som skal fylles med r√∏de feller p√• niv√• 1.
        // For hvert niv√• √∏kes andelen med et lite p√•slag (0.01 = 1 % for blokker og 0.007 = 0.7 % for feller).
        // blockPercent og hazardPercent har ogs√• en √∏vre grense (0.2 for blokker, 0.15 for feller).
        const baseBlockPercent = 0.1;
        const baseHazardPercent = 0.05;
        const blockPercent = Math.min(0.2, baseBlockPercent + (level - 1) * 0.01);
        const hazardPercent = Math.min(0.15, baseHazardPercent + (level - 1) * 0.007);
        // beregn antall blokker og feller basert p√• andelene over
        let numBlocks = Math.floor(totalCells * blockPercent);
        let numHazards = Math.floor(totalCells * hazardPercent);
        // maxObstaclesTotal: maksimal andel av brettet (her 35 %) som kan fylles med hindringer (blokker + feller).
        const maxObstaclesTotal = Math.floor(totalCells * 0.35);
        const totalObstacles = numBlocks + numHazards;
        if (totalObstacles > maxObstaclesTotal) {
            const ratio = maxObstaclesTotal / totalObstacles;
            numBlocks = Math.floor(numBlocks * ratio);
            numHazards = Math.floor(numHazards * ratio);
        }
        placeRandomCells('block', numBlocks);
        placeRandomCells('hazard', numHazards);
        // beregn antall bonuskuler (gule) for dette niv√•et. Bonuskuler gir ekstra poeng
        // men p√•virker ikke brettets l√∏sbarthet. Du kan justere formelen under for √•
        // endre hvor mange bonuskuler som plasseres. For eksempel starter vi med 1
        // bonuskule og √∏ker med ett for hver tredje niv√•, begrenset til 5.
        let numBonuses = 1 + Math.floor((level - 1) / 3);
        numBonuses = Math.min(5, numBonuses);
        placeRandomCells('bonus', numBonuses);
        // sjekk om brettet har en sti til m√•let
        solvable = hasPath();
        // hvis ikke, pr√∏v p√• nytt
    }
    // Tilbakestill antall trekk n√•r et nytt brett genereres.
    // Dette gj√∏r at spilleren starter hvert niv√• med en ny mengde trekk.
    resetMoves();
}

function placeRandomCells(type, count) {
    let placed = 0;
    while (placed < count) {
        let x = Math.floor(Math.random() * gridWidth);
        let y = Math.floor(Math.random() * gridHeight);
        if (board[y][x] === 'empty') {
            board[y][x] = type;
            placed++;
        }
    }
}

function drawBoard() {
    const container = document.getElementById('gameContainer');
    // Beregn st√∏rrelsen p√• containeren dynamisk. Ved rektangul√¶re brett
    // √∏nsker vi at lengste side skal fylle en viss andel av skjermen, og
    // at den andre siden skal beregnes ut fra gridWidth/gridHeight.
    // Vi tar utgangspunkt i den minste av vinduets bredde og h√∏yde for √•
    // sikre at brettet ikke g√•r utenfor skjermen. Juster scaleFactor for
    // √• endre hvor stor andel av skjermen brettet skal ta. Standard er 0.8
    // (80 % av mindre vindusdimensjon).
    const scaleFactor = 0.8;
    // Maksimal absolutt st√∏rrelse (px) p√• lengste side. Du kan endre maxBoardSize
    // for √• forhindre at brettet blir for stort p√• store skjermer.
    const maxBoardSize = 500;
    const minDimension = Math.min(window.innerWidth, window.innerHeight);
    let boardSquare = minDimension * scaleFactor;
    if (boardSquare > maxBoardSize) boardSquare = maxBoardSize;
    // Bestem om gridWidth eller gridHeight er den styrende for lengste side.
    const ratio = gridWidth / gridHeight;
    let widthPx, heightPx;
    if (ratio >= 1) {
        // Flere kolonner enn rader: brettet er bredere enn h√∏yt.
        widthPx = boardSquare;
        heightPx = boardSquare / ratio;
    } else {
        // Flere rader enn kolonner: brettet er h√∏yere enn bredt.
        heightPx = boardSquare;
        widthPx = boardSquare * ratio;
    }
    // Sett width og height p√• containeren.
    container.style.width = `${widthPx}px`;
    container.style.height = `${heightPx}px`;
    // Definer gridstrukturen (kolonner og rader) slik at hver celle f√•r
    // lik fraksjon av containeren.
    container.style.gridTemplateColumns = `repeat(${gridWidth}, 1fr)`;
    container.style.gridTemplateRows = `repeat(${gridHeight}, 1fr)`;
    // Rydd containeren f√∏r ny tegning
    container.innerHTML = '';
    for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
            const cell = document.createElement('div');
            cell.classList.add('cell');
            cell.classList.add(board[y][x]);
            container.appendChild(cell);
        }
    }
}

function startTimer() {
    startTime = Date.now();
    if (timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(() => {
        const now = Date.now();
        const elapsed = ((now - startTime)/1000).toFixed(1);
        document.getElementById('time').textContent = elapsed;
    }, 100);
}

function stopTimer() {
    if (timerInterval) {
        clearInterval(timerInterval);
    }
}

function updateScoreboard() {
    document.getElementById('score').textContent = score;
    document.getElementById('level').textContent = level;
    // Oppdater ogs√• antall gjenst√•ende trekk i brukergrensesnittet.
    document.getElementById('movesLeft').textContent = movesLeft;
    document.getElementById('highScore').textContent = highScore;
}

// Tilbakestill antall tilgjengelige trekk for et nytt niv√•. Trekk beregnes
// basert p√• brettst√∏rrelse og kan justeres for √∏nsket vanskelighetsgrad.
// Standardinnstillingen under gir dobbelt s√• mange trekk som brettets st√∏rrelse,
// pluss ett ekstra trekk. Du kan endre faktoren eller legge til et konstant
// p√•slag for √• gj√∏re spillet enklere eller vanskeligere.
function resetMoves() {
    // Beregn antall trekk ut fra bredde og h√∏yde p√• brettet. Du kan justere formelen
    // for √• endre vanskelighetsgraden. Her gir vi spilleren like mange trekk som
    // summen av brettets bredde og h√∏yde pluss 2.
    movesLeft = gridWidth + gridHeight + 2;
    // Oppdater visningen umiddelbart slik at scoreboardet viser riktige verdier
    document.getElementById('movesLeft').textContent = movesLeft;
}

function movePlayer(dx, dy) {
    if (gameOver) return;
    const newX = playerPos.x + dx;
    const newY = playerPos.y + dy;
    if (newX < 0 || newX >= gridWidth || newY < 0 || newY >= gridHeight) {
        return; // kan ikke g√• utenfor brettet
    }
    const destination = board[newY][newX];
    if (destination === 'block') {
        return; // kan ikke g√• inn i hindring
    } else if (destination === 'hazard') {
        // spillet over
        handleGameOver();
        return;
    } else if (destination === 'goal') {
        handleSuccess();
        return;
    } else if (destination === 'bonus') {
        // samler en bonuskule: gir ekstra poeng uten √• avslutte niv√•et
        // juster bonusPoeng for √• endre hvor mye hver bonuskule er verdt
        const bonusPoeng = 5;
        score += bonusPoeng;
        // flytt spilleren til bonusposisjonen
        board[playerPos.y][playerPos.x] = 'empty';
        playerPos.x = newX;
        playerPos.y = newY;
        board[playerPos.y][playerPos.x] = 'player';
        drawBoard();
        movesLeft--;
        // oppdater scoreboard (score, trekk og eventuell h√∏y score)
        // sjekk om ny h√∏y score er oppn√•dd midt i niv√•et
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('highScore', highScore);
        }
        updateScoreboard();
        if (movesLeft <= 0) {
            handleOutOfMoves();
        }
        return;
    }
    // flytt spilleren
    board[playerPos.y][playerPos.x] = 'empty';
    playerPos.x = newX;
    playerPos.y = newY;
    board[playerPos.y][playerPos.x] = 'player';
    drawBoard();
    // Reduser trekk og sjekk om spilleren har flere igjen.
    movesLeft--;
    // oppdater scoreboard slik at trekkverdien vises
    document.getElementById('movesLeft').textContent = movesLeft;
    if (movesLeft <= 0) {
        handleOutOfMoves();
        return;
    }
}

function handleSuccess() {
    // beregn tid og poeng
    stopTimer();
    const endTime = Date.now();
    const elapsedSeconds = (endTime - startTime)/1000;
    // poengformel: antall poeng √∏ker med kvadratet av brettst√∏rrelsen, minus tiden (i sekunder).
    // Just√©r 'base' eller formelen for √• endre poengberegningen.
    // poengformel: antall poeng √∏ker med arealet (bredde * h√∏yde) minus tiden.
    const base = gridWidth * gridHeight;
    const gained = Math.max(0, Math.floor(base - elapsedSeconds));
    score += gained;
    level += 1;
    // √òk basest√∏rrelsen etter hver femte niv√•.
    // Formelen under beregner en ny baseSize ut fra niv√•et.
    // N√•r (level-1) er 0-4 ‚Üí floor((level-1)/5) = 0 og basest√∏rrelsen forblir 3.
    // N√•r (level-1) er 5-9 ‚Üí floor((level-1)/5) = 1 og basest√∏rrelsen blir 4, osv.
    const newBase = 3 + Math.floor((level - 1) / 5);
    baseSize = Math.min(12, newBase);
    // Bestem om brettet skal v√¶re rektangul√¶rt i stedet for kvadratisk. Vi bruker en sjanse til √•
    // variere formfaktoren. Du kan justere rectChance for √• p√•virke hvor ofte dette skjer.
    const rectChance = 0.3; // 30 % sjanse for rektangul√¶rt brett
    if (Math.random() < rectChance && baseSize < 12) {
        // Velg tilfeldig om vi skal √∏ke bredden eller h√∏yden med 1, hvis mulig
        if (Math.random() < 0.5) {
            gridWidth = Math.min(12, baseSize + 1);
            gridHeight = baseSize;
        } else {
            gridHeight = Math.min(12, baseSize + 1);
            gridWidth = baseSize;
        }
    } else {
        // Standard kvadratisk brett
        gridWidth = baseSize;
        gridHeight = baseSize;
    }
    // vis en statusmelding i stedet for √• stoppe spillet med alert
    const statusEl = document.getElementById('statusMessage');
    statusEl.textContent = `Bra jobbet! Du tjente ${gained} poeng p√• ${elapsedSeconds.toFixed(1)} sekunder.`;
    // fjern meldingen etter et par sekunder
    setTimeout(() => {
        statusEl.textContent = '';
    }, 2000);
    // s√∏rg for at restart-knappen skjules n√•r man klarer et niv√•
    const restartButton = document.getElementById('restartBtn');
    if (restartButton) {
        restartButton.style.display = 'none';
    }
    // start neste niv√• umiddelbart
    initBoard();
    updateScoreboard();
    document.getElementById('time').textContent = '0.0';
    drawBoard();
    startTimer();
}

function handleGameOver() {
    stopTimer();
    gameOver = true;
    // vis statusmelding uten √• blokkere spillet
    const statusEl = document.getElementById('statusMessage');
    // Oppdater h√∏y score hvis dette er en ny rekord
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('highScore', highScore);
        statusEl.textContent = `Du traff en r√∏d kule! Spillet er over. Ny rekord: ${score}`;
    } else {
        statusEl.textContent = `Du traff en r√∏d kule! Spillet er over. Din endelige poengsum: ${score}`;
    }
    // oppdater poengtavlen s√• h√∏y score vises korrekt
    updateScoreboard();
    // t√∏m statusmeldingen slik at den ikke vises under startoverlegget
    statusEl.textContent = '';
    // vis startoverlegg med play-knapp og sluttpoeng
    showStartOverlay(`Spillet er over! Du fikk ${score} poeng.`);
}

// N√•r spilleren g√•r tom for trekk f√∏r m√•let er n√•dd.
function handleOutOfMoves() {
    stopTimer();
    gameOver = true;
    const statusEl = document.getElementById('statusMessage');
    // Oppdater h√∏y score ved spillslutt og vis melding
    if (score > highScore) {
        highScore = score;
        localStorage.setItem('highScore', highScore);
        statusEl.textContent = `Du gikk tom for trekk! Spillet er over. Ny rekord: ${score}`;
    } else {
        statusEl.textContent = `Du gikk tom for trekk! Spillet er over. Din endelige poengsum: ${score}`;
    }
    updateScoreboard();
    // t√∏m statusmeldingen slik at den ikke vises under startoverlegget
    statusEl.textContent = '';
    // vis startoverlegg med play-knapp og sluttpoeng
    showStartOverlay(`Spillet er over! Du fikk ${score} poeng.`);
}

function restartGame() {
    baseSize = 3;
    gridWidth = 3;
    gridHeight = 3;
    score = 0;
    level = 1;
    gameOver = false;
    initBoard();
    updateScoreboard();
    document.getElementById('time').textContent = '0.0';
    drawBoard();
    startTimer();
    document.getElementById('restartBtn').style.display = 'none';
}

// Start et nytt spill fra startskjermen. Skjuler startoverlegget og
// kaller restartGame() for √• initialisere et nytt spill.
function startGame() {
    hideStartOverlay();
    restartGame();
}

document.addEventListener('keydown', (event) => {
    if (gameOver) return;
    switch (event.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
            movePlayer(0, -1);
            break;
        case 'ArrowDown':
        case 's':
        case 'S':
            movePlayer(0, 1);
            break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
            movePlayer(-1, 0);
            break;
        case 'ArrowRight':
        case 'd':
        case 'D':
            movePlayer(1, 0);
            break;
    }
});

document.getElementById('restartBtn').addEventListener('click', restartGame);

// initialiser spillet ved lasting
window.onload = () => {
    // p√•f√∏r lagret tema (lys/m√∏rk modus)
    applyStoredTheme();
    // legg til klikkh√•ndtering for tema-knappen
    const themeBtn = document.getElementById('themeToggle');
    if (themeBtn) {
        themeBtn.addEventListener('click', toggleTheme);
    }
    // hent lagret h√∏yeste poengsum fra localStorage
    const storedHigh = localStorage.getItem('highScore');
    if (storedHigh !== null) {
        highScore = parseInt(storedHigh) || 0;
    }
    // Oppdater poengtavlen med highscore f√∏r spillstart
    updateScoreboard();
    // vis startoverlegget med en velkomstmelding
    showStartOverlay('Velkommen!');
    // legg til klikkh√•ndtering for startknappen
    const startBtn = document.getElementById('startButton');
    if (startBtn) {
        startBtn.addEventListener('click', startGame);
    }
};
</script>
</body>
</html>
