<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simple Tier List</title>
  <style>
    /*
      Simple style sheet for a local tier list.

      Tiers consist of a colored header and an area where items
      can be moved around with drag-and-drop. The colors and names can
      be changed for each tier, and new items can be added via the controls
      at the top. Finally, the layout can be saved to the browser's localStorage.
    */
    :root {
      /* Tier header width. Adjusted to make the boxes a bit narrower */
      --header-width: 110px;
      --tier-gap: 8px;
      /* Color variables for light mode */
      --background: #f8f9fa;
      --foreground: #333333;
      --item-bg: #ffffff;
      --tier-items-bg: #fafafa;
      --control-bg: #007bff;
      --control-hover-bg: #0056b3;
      --button-text-color: #ffffff;
    }

    /* When data-theme=dark is set on documentElement (html), the variables for dark mode are overridden */
    [data-theme="dark"] {
      --background: #121212;
      --foreground: #e0e0e0;
      --item-bg: #1e1e1e;
      --tier-items-bg: #2a2a2a;
      --control-bg: #0d6efd;
      --control-hover-bg: #0a58ca;
      --button-text-color: #ffffff;
    }

    body {
      font-family: Arial, sans-serif;
      background-color: var(--background);
      margin: 0;
      padding: 20px;
      color: var(--foreground);
    }

    h1 {
      text-align: center;
      margin-bottom: 15px;
      color: var(--foreground);
    }

    /* Allow editing of page title without showing an ugly border.
        Instead, show a discrete dashed border when the field is in focus. */
    #pageTitle[contenteditable] {
      border: none;
      outline: none;
      cursor: text;
      display: inline-block;
      padding: 2px 4px;
      border-radius: 4px;
    }
    #pageTitle[contenteditable]:focus {
      outline: 2px dashed #007bff;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 15px;
      align-items: center;
    }

    .controls input[type="text"] {
      flex-grow: 1;
      padding: 8px 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .controls button {
      padding: 8px 12px;
      border: none;
      background-color: var(--control-bg);
      color: var(--button-text-color);
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s ease;
    }

    .controls button:hover {
      background-color: var(--control-hover-bg);
    }

    /* Special styling for the theme toggle button to make it small and distinct. */
    #themeToggle {
      width: 2.1rem;
      height: 2.1rem;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1rem;
      border-radius: 50%;
      background-color: transparent;
      border: 2px solid var(--control-bg);
      color: var(--control-bg);
      margin-left: auto;
    }
    #themeToggle:hover {
      background-color: var(--control-bg);
      color: var(--button-text-color);
    }

    /* Tier layout */
    .tier {
      display: flex;
      border: 1px solid #ddd;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: var(--tier-gap);
      background-color: #fff;
    }

    .tier-header {
      width: var(--header-width);
      padding: 5px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      gap: 3px;
      box-sizing: border-box;
    }

    .tier-header input[type="text"] {
      width: 100%;
      border: none;
      font-weight: bold;
      font-size: 1rem;
      background-color: transparent;
      padding: 4px;
      outline: none;
      /* allow automatic line breaks for long category names */
      white-space: normal;
      overflow-wrap: anywhere;
      /* inherit color from the header for good contrast */
      color: inherit;
    }

    /* Progress bar inside the tier header */
    .progress-container {
      width: 100%;
      height: 6px;
      background-color: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
      overflow: hidden;
    }
    .progress-bar {
      height: 100%;
      width: 0%;
      background-color: currentColor;
    }

    /* Footer with count, percentage, color picker and remove button */
    .tier-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 4px;
      font-size: 0.8rem;
    }
    /* Specific classes to easily find count and percentage in JS */
    .count-info {
      /* no specific styles yet */
    }
    .percent-info {
      /* no specific styles yet */
    }

    /* Trash bin for removing items */
    #trashBin {
      width: 100px;
      height: 50px;
      border: 2px dashed #999;
      border-radius: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1rem;
      margin-top: 10px;
      cursor: pointer;
      color: var(--foreground);
      background-color: var(--tier-items-bg);
      transition: background-color 0.2s ease, border-color 0.2s ease;
    }
    #trashBin.drag-over {
      background-color: #ffe6e6;
      border-color: #ff6b6b;
    }
    .tier-footer input[type="color"] {
      width: 1.3rem;
      height: 1.3rem;
      border: none;
      padding: 0;
      cursor: pointer;
    }

    .tier-items {
      flex-grow: 1;
      /* Reduce min-height so boxes don't get so tall */
      min-height: 50px;
      padding: 8px;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      gap: 8px;
      background-color: var(--tier-items-bg);
      transition: background-color 0.2s ease;
    }

    .tier-items.drag-over {
      background-color: #e6f7ff;
      border: 2px dashed #007bff;
    }

    .item {
      padding: 6px 10px;
      background-color: var(--item-bg);
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: move;
      user-select: none;
      font-size: 0.85rem;
      /* allow line wraps when extra fields are shown */
      white-space: normal;
      /* Stack rows for text and extra fields */
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      color: var(--foreground);
    }

    .item.dragging {
      opacity: 0.6;
    }

    /* Small extra fields that are permanently displayed on the items */
    .extra-fields {
      font-size: 0.7rem;
      opacity: 0.8;
      margin-top: 2px;
      color: var(--foreground);
    }

    /* Settings panel for column view */
    #settingsOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      display: none;
    }

    #settingsPanel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: var(--item-bg);
      color: var(--foreground);
      border: 2px solid #ccc;
      border-radius: 6px;
      padding: 20px;
      z-index: 1001;
      min-width: 320px;
      display: none;
    }
    #settingsPanel h2 {
      margin-top: 0;
      margin-bottom: 10px;
      font-size: 1.2rem;
    }
    .column-setting {
      margin-bottom: 10px;
      display: flex;
      flex-direction: column;
    }
    .column-setting label {
      font-size: 0.8rem;
      margin-bottom: 3px;
    }
    .settings-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 15px;
    }
    #settingsBtn {
      width: 2.1rem;
      height: 2.1rem;
      padding: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.1rem;
      border-radius: 50%;
      background-color: transparent;
      border: 2px solid var(--control-bg);
      color: var(--control-bg);
      margin-left: 5px;
    }
    #settingsBtn:hover {
      background-color: var(--control-bg);
      color: var(--button-text-color);
    }

    /* Count information in the tier header */
    .counts {
      font-size: 0.8rem;
      opacity: 0.8;
    }

    /* Button to remove a tier */
    .remove-tier {
      background: none;
      border: none;
      color: inherit;
      font-weight: bold;
      cursor: pointer;
      align-self: flex-end;
      padding: 0;
    }

    /* Duplicate warning */
    #duplicateMsg {
      background-color: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
      padding: 4px 8px;
      border-radius: 4px;
      white-space: nowrap;
      font-size: 0.85rem;
      pointer-events: none;
      z-index: 1000;
    }

    /* Responsive adjustments */
    @media (max-width: 600px) {
      :root {
        --header-width: 100px;
      }
      .controls input[type="text"] {
        flex-basis: 100%;
      }
    }

    /* Print-friendly style: hide controls and trash bin */
    @media print {
      .controls,
      #trashBin,
      #settingsOverlay,
      #settingsPanel,
      #duplicateMsg {
        display: none !important;
      }
      body {
        margin: 0;
        padding: 0;
      }
    }
  </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
    <div class="container">
        <h1 id="pageTitle" contenteditable="true" spellcheck="false">Simple Tier List</h1>
    <div class="controls">
            <input type="text" id="bulkTitles" placeholder="Add title(s) … (separate with | or ;)" style="flex-grow:1;" />
      <button id="addBulkBtn">Add</button>
      
            <input type="file" id="fileInput" accept=".txt,.csv,.xls,.xlsx" style="display:none" />
      <button id="importBtn">Import file</button>

      <button id="addTierBtn">Add tier</button>
            <button id="themeToggle" title="Toggle theme">🌙</button>
            <button id="settingsBtn" title="Settings">⚙</button>
    </div>

        <div id="duplicateMsg" style="display:none; position: absolute;"></div>

        <div class="controls" style="margin-top: 5px;">
      <button id="sortUnrankedBtn">Sort unranked (A–Z)</button>
      <button id="shuffleUnrankedBtn">Shuffle unranked</button>
    </div>
    <div id="tiers">
          </div>
        <div class="controls" id="bottomControls" style="margin-top: 10px;">
      <button id="saveBtn">Save layout</button>
      <button id="resetBtn">Reset</button>
      <button id="exportJsonBtn">Export JSON</button>
      <input type="file" id="importJsonInput" accept=".json" style="display:none" />
      <button id="importJsonBtn">Import JSON</button>
            <button id="exportImageBtn">Export image</button>
    </div>

        <div id="trashBin" title="Drag items here to delete">🗑 Delete</div>

        <div id="settingsOverlay"></div>
    <div id="settingsPanel">
      <h2>Column Settings</h2>
            <div id="columnSettingsContainer"></div>
      <div class="settings-actions">
        <button id="cancelSettingsBtn">Cancel</button>
        <button id="saveSettingsBtn">Save</button>
      </div>
    </div>
  </div>

  <script>
    /*
      JavaScript for controlling the tier list. The following functions are supported:
        – Create default tiers (S, A, B, C, D, Unranked) with color.
        – Dynamically edit the name and color for each tier.
        – Add new items that can be dragged and dropped between tiers.
        – Drag-and-drop with HTML5 API for both reordering within the same tier and moving between tiers.
        – Save and load layout from the browser's localStorage.
        – Reset to default.
    */

    // Define default tiers. Use a list of objects containing name, color, and an empty list for items.
    const defaultTiers = [
      { name: 'S', color: '#f94144', items: [] },
      { name: 'A', color: '#f3722c', items: [] },
      { name: 'B', color: '#f9844a', items: [] },
      { name: 'C', color: '#f8961e', items: [] },
      { name: 'D', color: '#f9c74f', items: [] },
      { name: 'Unranked', color: '#90be6d', items: [] }
    ];

    // Global state for tiers and next item ID
    let tiers = [];
    let nextItemId = 1;

    // Column settings: an array of up to 6 objects { label, showHover, showPermanent }.
    // These are used to determine how extra columns are displayed in tooltips and permanently on the items.
    let columnSettings = [];
    // Maximum number of extra columns (from Excel column B to G)
    const MAX_EXTRA_COLS = 6;

    // Global variables for drag-and-drop. Used to move items between tiers.
    // When an item begins to be dragged, currentDraggedEl is set to the element.
    // This means we don't have to rely on dataTransfer to retrieve the ID on drop.
    let currentDraggedEl = null;

    // Flag indicating if an element was deleted in the trash-drop handler. Used to prevent reversal in dragend.
    let wasDeleted = false;

    /**
     * Calculate contrast color (black or white) based on background color.
     * @param {string} hex – Color in the format #rrggbb
     * @returns {string} '#000000' or '#ffffff'
     */
    function getContrastColor(hex) {
      // Remove # if present
      hex = hex.replace('#', '');
      if (hex.length === 3) {
        hex = hex.split('').map(c => c + c).join('');
      }
      const r = parseInt(hex.substr(0, 2), 16);
      const g = parseInt(hex.substr(2, 2), 16);
      const b = parseInt(hex.substr(4, 2), 16);
      // Calculate luminance according to the YIQ formula
      const yiq = (r * 299 + g * 587 + b * 114) / 1000;
      return yiq >= 128 ? '#000000' : '#ffffff';
    }

    /**
     * Lighten a hex color by a percentage. Used for the progress bar.
     * @param {string} hex Color in format #rrggbb
     * @param {number} percent Percentage to lighten (0–1)
     * @returns {string} New hex color
     */
    function lightenColor(hex, percent) {
      hex = hex.replace('#', '');
      if (hex.length === 3) {
        hex = hex.split('').map(c => c + c).join('');
      }
      let r = parseInt(hex.substr(0, 2), 16);
      let g = parseInt(hex.substr(2, 2), 16);
      let b = parseInt(hex.substr(4, 2), 16);
      r = Math.round(r + (255 - r) * percent);
      g = Math.round(g + (255 - g) * percent);
      b = Math.round(b + (255 - b) * percent);
      return '#' + r.toString(16).padStart(2, '0') +
                   g.toString(16).padStart(2, '0') +
                   b.toString(16).padStart(2, '0');
    }

    /**
     * Convert a text to title case (first letter of each word is capitalized).
     * Words are separated by spaces. If the text contains hyphens or other
     * separators, each part is treated separately. If you want to keep existing
     * capital letters within words, you must adjust this function.
     * @param {string} str
     * @returns {string}
     */
    function toTitleCase(str) {
      return str.trim()
        .split(/\s+/)
        .map(word => {
          if (!word) return '';
          const first = word[0].toUpperCase();
          const rest = word.slice(1).toLowerCase();
          return first + rest;
        })
        .join(' ');
    }

    // Page title is also saved in localStorage
    let pageTitle = 'Simple Tier List';

    /**
     * Load column settings from localStorage or use default values.
     */
    function loadColumnSettings() {
      try {
        const saved = localStorage.getItem('tierColumnSettings');
        if (saved) {
          const arr = JSON.parse(saved);
          if (Array.isArray(arr) && arr.length === MAX_EXTRA_COLS) {
            columnSettings = arr;
            return;
          }
        }
      } catch (e) {
        console.warn('Could not read column settings from localStorage', e);
      }
      // If no saved settings, set defaults
      columnSettings = [];
      for (let i = 0; i < MAX_EXTRA_COLS; i++) {
        // Default name based on the alphabet (B, C, D, E, F, G)
        const colName = String.fromCharCode(66 + i);
        columnSettings.push({ label: `Col ${colName}`, showHover: true, showPermanent: false });
      }
    }

    /**
     * Save column settings to localStorage
     */
    function saveColumnSettings() {
      try {
        localStorage.setItem('tierColumnSettings', JSON.stringify(columnSettings));
      } catch (e) {
        console.warn('Could not save column settings', e);
      }
    }

    /**
     * Apply column settings to all existing items.
     */
    function applySettingsToAllItems() {
      const itemEls = document.querySelectorAll('.item');
      itemEls.forEach(el => {
        const obj = findItemById(el.id);
        if (obj) {
          applySettingsToItem(el, obj);
        }
      });
    }

    /**
     * Apply column settings to a single item.
     * @param {HTMLElement} el – DOM element for the item
     * @param {Object} item – Object with text and extra fields
     */
    function applySettingsToItem(el, item) {
      // Get extra fields as an array (can be undefined)
      const extraArr = Array.isArray(item.extra) ? item.extra : [];
      // Build tooltip
      const hoverParts = [];
      // Title (always included first)
      hoverParts.push(item.text);
      for (let i = 0; i < MAX_EXTRA_COLS; i++) {
        const value = extraArr[i];
        if (value !== undefined && value !== null && String(value).trim()) {
          const cfg = columnSettings[i] || { label: `Col ${String.fromCharCode(66 + i)}`, showHover: true, showPermanent: false };
          if (cfg.showHover) {
            hoverParts.push(`${cfg.label} - ${String(value).trim()}`);
          }
        }
      }
      el.title = hoverParts.join(', ');
      // Remove existing permanent extra fields container if it exists
      const existing = el.querySelector('.extra-fields');
      if (existing) existing.remove();
      const permanentParts = [];
      for (let i = 0; i < MAX_EXTRA_COLS; i++) {
        const value = extraArr[i];
        if (value !== undefined && value !== null && String(value).trim()) {
          const cfg = columnSettings[i] || { label: `Col ${String.fromCharCode(66 + i)}`, showHover: true, showPermanent: false };
          if (cfg.showPermanent) {
            permanentParts.push({ label: cfg.label, value: String(value).trim() });
          }
        }
      }
      if (permanentParts.length > 0) {
        const container = document.createElement('div');
        container.className = 'extra-fields';
        permanentParts.forEach(part => {
          const span = document.createElement('span');
          span.textContent = `${part.label} - ${part.value}`;
          container.appendChild(span);
        });
        el.appendChild(container);
      }
    }

    /**
     * Generate a unique ID for a new item.
     */
    function generateItemId() {
      return 'item-' + nextItemId++;
    }

    /**
     * Create the DOM for a tier and its items. Returns a DOM element.
     * @param {Object} tierObj – The tier to be displayed.
     * @param {number} tierIndex – The index in the tiers array.
     */
    function createTierElement(tierObj, tierIndex, totalCount) {
      const tier = document.createElement('div');
      tier.className = 'tier';

      // Header for tier (name, progress and footer)
      const header = document.createElement('div');
      header.className = 'tier-header';
      header.style.backgroundColor = tierObj.color;
      const contrastColor = getContrastColor(tierObj.color);
      header.style.color = contrastColor;

      // Prevent drop on header and name field
      header.addEventListener('dragover', (ev) => {
        ev.preventDefault();
      });
      header.addEventListener('drop', (ev) => {
        ev.preventDefault();
      });

      // Top: name field
      const nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.value = tierObj.name;
      nameInput.title = 'Change tier name';
      nameInput.addEventListener('input', () => {
        tierObj.name = nameInput.value;
      });
      // Prevent drag/drop from putting data into the name field
      ['dragover', 'drop'].forEach(evtName => {
        nameInput.addEventListener(evtName, (ev) => {
          ev.preventDefault();
        });
      });
      header.appendChild(nameInput);

      // Middle: progress bar
      const progressContainer = document.createElement('div');
      progressContainer.className = 'progress-container';
      const progressBar = document.createElement('div');
      progressBar.className = 'progress-bar';
      // Calculate percentage of items in this tier
      const tierCount = tierObj.items.length;
      const denom = totalCount || 0;
      let percent = 0;
      if (denom > 0) percent = Math.round((tierCount / denom) * 100);
      progressBar.style.width = `${percent}%`;
      // Lighten the color slightly for the progress bar
      // Use a stronger lightening to make the progress more visible
      progressBar.style.backgroundColor = lightenColor(tierObj.color, 0.7);
      progressContainer.appendChild(progressBar);
      header.appendChild(progressContainer);

      // Bottom: footer with counts, percentage, color picker, and remove button
      const footer = document.createElement('div');
      footer.className = 'tier-footer';
      // Count info (displayed in parentheses)
      const countSpan = document.createElement('span');
      countSpan.className = 'count-info';
      countSpan.textContent = `(${tierCount}/${denom}),`;
      // Percentage info
      const percentSpan = document.createElement('span');
      percentSpan.className = 'percent-info';
      percentSpan.textContent = denom > 0 ? `${percent}%` : '0%';
      // Color picker (small)
      const colorInput = document.createElement('input');
      colorInput.type = 'color';
      colorInput.value = tierObj.color;
      colorInput.title = 'Select tier color';
      // On color change: update background, contrast, progress bar, and text colors
      colorInput.addEventListener('input', () => {
        tierObj.color = colorInput.value;
        // Update background color
        header.style.backgroundColor = tierObj.color;
        // Update progress bar color with lightening
        progressBar.style.backgroundColor = lightenColor(tierObj.color, 0.7);
        // Update contrast color
        const newContrast = getContrastColor(tierObj.color);
        header.style.color = newContrast;
        countSpan.style.color = newContrast;
        percentSpan.style.color = newContrast;
        removeBtn && (removeBtn.style.color = newContrast);
      });
      // Prevent drag from being dropped on the color picker
      ['dragover', 'drop'].forEach(evtName => {
        colorInput.addEventListener(evtName, (ev) => {
          ev.preventDefault();
        });
      });

      // Remove button (only if not unranked)
      let removeBtn = null;
      if (tierIndex < tiers.length - 1) {
        removeBtn = document.createElement('button');
        removeBtn.className = 'remove-tier';
        removeBtn.textContent = '×';
        removeBtn.title = 'Remove this tier';
        removeBtn.addEventListener('click', () => {
          removeTier(tierIndex);
        });
      }
      // Set text colors in the footer for contrast
      countSpan.style.color = contrastColor;
      percentSpan.style.color = contrastColor;
      // Add elements to footer
      footer.appendChild(countSpan);
      footer.appendChild(percentSpan);
      footer.appendChild(colorInput);
      if (removeBtn) footer.appendChild(removeBtn);

      header.appendChild(footer);

      // Item container
      const itemsContainer = document.createElement('div');
      itemsContainer.className = 'tier-items';
      itemsContainer.dataset.tierIndex = tierIndex;
      // Dragover event allows drop
      itemsContainer.addEventListener('dragover', (ev) => {
        ev.preventDefault();
        // Show that we allow moving
        if (ev.dataTransfer) {
          ev.dataTransfer.dropEffect = 'move';
        }
      });
      itemsContainer.addEventListener('dragenter', (ev) => {
        ev.preventDefault();
        itemsContainer.classList.add('drag-over');
      });
      itemsContainer.addEventListener('dragleave', () => {
        itemsContainer.classList.remove('drag-over');
      });
      itemsContainer.addEventListener('drop', (ev) => {
        ev.preventDefault();
        // Stop bubbling to prevent other drop handlers from running
        ev.stopPropagation();
        const draggedEl = currentDraggedEl;
        if (draggedEl) {
          // Remove highlighting class from all containers
          const allContainers = document.querySelectorAll('.tier-items');
          allContainers.forEach(c => c.classList.remove('drag-over'));
          // Add the element to this container (automatically moves from its previous container)
          itemsContainer.appendChild(draggedEl);
          // Do not update the data model here; it is done in dragend to avoid duplication.
        }
      });

      // Add existing items to itemsContainer
      tierObj.items.forEach(item => {
        const itemEl = createItemElement(item);
        itemsContainer.appendChild(itemEl);
      });

      tier.appendChild(header);
      tier.appendChild(itemsContainer);
      return tier;
    }

    /**
     * Create a DOM element for an item.
     * @param {Object} item – Object with ID and text.
     */
    function createItemElement(item) {
      const el = document.createElement('div');
      el.className = 'item';
      el.id = item.id;
      // Store a reference to the item object on the DOM element for later use when reordering
      el._item = item;
      el.textContent = item.text;
      // Tooltip and extra fields are handled via applySettingsToItem
      el.draggable = true;
      el.addEventListener('dragstart', (ev) => {
        // Store reference to the dragged element globally
        currentDraggedEl = el;
        // Also set dataTransfer for compatibility, but do not rely on it
        ev.dataTransfer.setData('text/plain', el.id);
        ev.dataTransfer.effectAllowed = 'move';
        setTimeout(() => {
          el.classList.add('dragging');
        }, 0);
        // Store original parent to be able to move back if dropped in an invalid area
        el._originalParent = el.parentElement;
      });
      el.addEventListener('dragend', () => {
        el.classList.remove('dragging');
        // After dragging ends, update the data model and the counts/progress.
        // This also captures cases where the drop occurs outside a valid container.
        // If the element was deleted in the trash-drop handler, prevent reversal and reset the flag
        if (!wasDeleted) {
          // If the element is no longer in a tier-items container or the trash bin, move it back to the original container
          const parent = el.parentElement;
          const trash = document.getElementById('trashBin');
          if (!parent || (!parent.classList.contains('tier-items') && parent !== trash)) {
            if (el._originalParent) {
              el._originalParent.appendChild(el);
            }
          }
        }
        // In any case, update data model and counts/progress
        updateDataFromDOM();
        updateCountsAndProgress();
        // Reset flag and global variable
        wasDeleted = false;
        currentDraggedEl = null;
      });
      // Allow reordering by dropping on another element
      el.addEventListener('dragover', (ev) => {
        ev.preventDefault();
        if (ev.dataTransfer) {
          ev.dataTransfer.dropEffect = 'move';
        }
      });
      el.addEventListener('drop', (ev) => {
        ev.preventDefault();
        // Stop bubbling so the container does not also handle the drop (prevents the element from being moved twice)
        ev.stopPropagation();
        // Get the dragged element from the global variable
        const draggedEl = currentDraggedEl;
        if (!draggedEl || draggedEl === el) return;
        // Move the element before this element
        el.parentElement.insertBefore(draggedEl, el);
        // Do not update the data model here; it is done in dragend.
      });
      // Apply column settings to this element
      applySettingsToItem(el, item);
      return el;
    }

    /**
     * Render all tiers in the DOM based on the global "tiers" variable.
     */
    function renderTiers() {
      const tiersContainer = document.getElementById('tiers');
      tiersContainer.innerHTML = '';
      // Calculate the total number of items across all tiers
      const totalCount = tiers.reduce((sum, t) => sum + t.items.length, 0);
      tiers.forEach((tierObj, index) => {
        const tierEl = createTierElement(tierObj, index, totalCount);
        tiersContainer.appendChild(tierEl);
      });

      // Do not update the page title here; it is controlled by the contenteditable h1
    }

    /**
     * Add a new item to the Unranked tier (last tier). Creates item object and DOM element.
     * @param {string} text – The item text.
     */
    function addNewItem(text, extra = null) {
      if (!text.trim()) return;
      const id = generateItemId();
      const itemObj = { id, text };
      if (extra) {
        itemObj.extra = extra;
      }
      // Add to the last tier (Unranked) in the data
      tiers[tiers.length - 1].items.push(itemObj);
      // Create DOM and add to the last tier
      const itemEl = createItemElement(itemObj);
      const containers = document.querySelectorAll('.tier-items');
      const unrankedContainer = containers[containers.length - 1];
      unrankedContainer.appendChild(itemEl);
      // Update counts/progress without a full re-render
      updateCountsAndProgress();
    }

    /**
     * Fetch data from the DOM to update the global "tiers" (names, colors, item order).
     */
    function updateDataFromDOM() {
      tiers.forEach((tierObj, tierIndex) => {
        // Update name and color
        const tierEl = document.querySelectorAll('.tier')[tierIndex];
        const nameInput = tierEl.querySelector('.tier-header input[type="text"]');
        const colorInput = tierEl.querySelector('.tier-header input[type="color"]')
