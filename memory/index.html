<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pokémon Guessing Game</title>
  <!-- Link to external CSS for styling -->
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <!-- Back button linking to sarcasm.games.com -->
  <button class="back-button" id="back-button" onclick="location.href='https://sarcasm.games'">Back to main menu</button>

  <div id="start-screen" class="start-screen">
    <h1>Pokémon Guessing Game</h1>
    <div class="section">
      <label>Select Generations:</label>
      <div class="gen-selection" id="generation-options">
        <!-- Generation checkboxes inserted by script -->
      </div>
    </div>
    <div class="section">
      <label>Select Difficulty:</label>
      <div class="difficulty">
        <label><input type="radio" name="difficulty" value="easy" checked> Easy</label>
        <label><input type="radio" name="difficulty" value="medium"> Medium</label>
        <label><input type="radio" name="difficulty" value="hard"> Hard</label>
        <label><input type="radio" name="difficulty" value="expert"> Expert</label>
      </div>
    </div>
    <div class="section">
      <label>Number of Images (1-99):</label>
      <input type="number" id="num-images" class="num-images" min="1" max="99" value="5" />
    </div>
    <button id="start-button" class="control-button">Start Game</button>
  </div>

  <div id="game-area" class="game-container">
    <div id="scoreboard">
      <div id="lives-display">Lives: 3</div>
      <div id="score-display">Score: 0</div>
      <div id="progress-display">0 / 0</div>
    </div>
    <div id="pokemon-container">
      <!-- Pokémon sprite will be set as background image -->
      <div class="overlay-grid" id="overlay-grid"></div>
    </div>
    <div id="guess-section" class="guess-section">
      <input type="text" id="guess-input" placeholder="Enter Pokémon name" autocomplete="off" />
      <button id="guess-button" class="control-button">Guess</button>
    </div>
    <div id="message"></div>
    <!-- Button to return to the settings/start screen -->
    <button id="settings-button" class="control-button">Back to settings</button>
  </div>

  <div id="summary-screen" class="end-screen">
    <h2>Game Summary</h2>
    <p id="summary-text"></p>
    <p>Thanks for playing!</p>
  </div>

  <script>
    // JavaScript for the Pokémon guessing game
    (function() {
      // Map difficulty to grid size and score multiplier
      const difficultySettings = {
        easy: { grid: 3, multiplier: 1 },
        medium: { grid: 4, multiplier: 2 },
        hard: { grid: 5, multiplier: 3 },
        expert: { grid: 7, multiplier: 5 },
      };

      // Insert generation checkboxes (I to IX)
      const generationOptions = document.getElementById('generation-options');
      const romanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
      romanNumerals.forEach((roman, index) => {
        // Create a labelled box for each generation.  The input is hidden via CSS and
        // the span displays the Roman numeral.  When the checkbox is checked the
        // adjacent span will be styled as selected.
        const label = document.createElement('label');
        label.className = 'gen-box';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = index + 1; // generation numbers start at 1
        checkbox.checked = index === 0; // default select gen I
        const span = document.createElement('span');
        span.textContent = roman;
        label.appendChild(checkbox);
        label.appendChild(span);
        generationOptions.appendChild(label);
      });

      // Game variables
      let selectedGenerations = [];
      let difficultyKey = 'easy';
      let numImages = 5;
      let gameData = [];
      let currentIndex = 0;
      let currentPokemonName = '';
      let totalScore = 0;
      let livesLeft = 3;
      let flippedCount = 0;
      let maxPoints = 0;
      let maxTiles = 0;
      let scorePotential = 0;
      let correctCount = 0;

      const startScreen = document.getElementById('start-screen');
      const gameArea = document.getElementById('game-area');
      const summaryScreen = document.getElementById('summary-screen');
      const summaryText = document.getElementById('summary-text');
      const livesDisplay = document.getElementById('lives-display');
      const scoreDisplay = document.getElementById('score-display');
      const progressDisplay = document.getElementById('progress-display');
      const pokemonContainer = document.getElementById('pokemon-container');
      const overlayGrid = document.getElementById('overlay-grid');
      const guessInput = document.getElementById('guess-input');
      const guessButton = document.getElementById('guess-button');
      const messageDiv = document.getElementById('message');
      const settingsButton = document.getElementById('settings-button');

      // Utility: fetch JSON with caching to respect fair use
      const cache = {};
      async function fetchJSON(url) {
        if (cache[url]) {
          return cache[url];
        }
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error('Network response was not ok');
        }
        const data = await response.json();
        cache[url] = data;
        return data;
      }

      // Generate a pool of Pokémon species from selected generations
      async function buildPokemonPool(gens) {
        let species = [];
        for (const gen of gens) {
          try {
            const genData = await fetchJSON(`https://pokeapi.co/api/v2/generation/${gen}/`);
            // The generation endpoint contains a list of pokemon_species
            // Each item has name and url; we extract name
            const speciesList = genData.pokemon_species || genData.species || [];
            for (const item of speciesList) {
              species.push(item.name);
            }
          } catch (err) {
            console.error('Error fetching generation ' + gen + ':', err);
          }
        }
        return species;
      }

      // Fetch sprite URL for a given Pokémon name
      async function fetchSprite(name) {
        const data = await fetchJSON(`https://pokeapi.co/api/v2/pokemon/${name.toLowerCase()}`);
        // Prefer official artwork if available
        let spriteUrl = null;
        if (data.sprites) {
          if (data.sprites.other && data.sprites.other['official-artwork'] && data.sprites.other['official-artwork'].front_default) {
            spriteUrl = data.sprites.other['official-artwork'].front_default;
          } else if (data.sprites.front_default) {
            spriteUrl = data.sprites.front_default;
          }
        }
        return spriteUrl;
      }

      // -----------------------------------------------------------------------------
      // Image analysis helpers
      // These functions fetch the sprite image, draw it to an offscreen canvas and
      // compute a bounding box around the non-empty portion of the sprite.  Any
      // overlay cells that fall completely outside this bounding box are marked
      // blank and will be revealed from the start, reducing the number of flips
      // required.

      // Fetch image data from a URL and return ImageData along with dimensions
      async function getImageDataFromUrl(url) {
        const response = await fetch(url);
        const blob = await response.blob();
        const bitmap = await createImageBitmap(blob);
        const canvas = document.createElement('canvas');
        canvas.width = bitmap.width;
        canvas.height = bitmap.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(bitmap, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        return { imageData, width: canvas.width, height: canvas.height };
      }

      // Compute a bounding box around all pixels that are not transparent or pure white
      function computeBoundingBox(imageData, width, height) {
        let minX = width;
        let minY = height;
        let maxX = 0;
        let maxY = 0;
        let found = false;
        const data = imageData.data;
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const idx = (y * width + x) * 4;
            const r = data[idx];
            const g = data[idx + 1];
            const b = data[idx + 2];
            const a = data[idx + 3];
            // Treat pixels as part of the sprite if they are not highly transparent
            // or if they are not near-white (brightness threshold).  This helps
            // exclude large transparent or white margins around sprites.
            const brightness = (r + g + b) / 3;
            if (a > 10 || brightness < 240) {
              found = true;
              if (x < minX) minX = x;
              if (y < minY) minY = y;
              if (x > maxX) maxX = x;
              if (y > maxY) maxY = y;
            }
          }
        }
        if (!found) {
          // If no non-empty pixel is found, return the entire image
          return { minX: 0, minY: 0, maxX: width - 1, maxY: height - 1 };
        }
        return { minX, minY, maxX, maxY };
      }

      // Determine which cells in the overlay grid fall entirely outside the bounding box
      function computeBlankCells(bbox, imgW, imgH, grid) {
        const blankIndices = [];
        const cellWidth = imgW / grid;
        const cellHeight = imgH / grid;
        for (let row = 0; row < grid; row++) {
          for (let col = 0; col < grid; col++) {
            const cellX1 = col * cellWidth;
            const cellY1 = row * cellHeight;
            const cellX2 = cellX1 + cellWidth;
            const cellY2 = cellY1 + cellHeight;
            // A cell is blank if it does not intersect the bounding box at all
            if (cellX2 < bbox.minX || cellX1 > bbox.maxX || cellY2 < bbox.minY || cellY1 > bbox.maxY) {
              blankIndices.push(row * grid + col);
            }
          }
        }
        return blankIndices;
      }

      // Fetch sprite image and compute blank overlay cells for a given grid size
      async function getBlankCellsForSprite(url, grid) {
        try {
          const { imageData, width, height } = await getImageDataFromUrl(url);
          const bbox = computeBoundingBox(imageData, width, height);
          return computeBlankCells(bbox, width, height, grid);
        } catch (err) {
          console.error('Error analyzing sprite', err);
          return [];
        }
      }

      // Set up a new round with a Pokémon
      async function setupPokemonRound() {
        messageDiv.textContent = '';
        guessInput.value = '';
        // Reset counts and state for a new round
        flippedCount = 0;
        livesLeft = 3;
        const difficulty = difficultySettings[difficultyKey];

        livesDisplay.textContent = `Lives: ${livesLeft}`;

        // Pick random Pokémon from gameData
        currentPokemonName = gameData[currentIndex];
        // Fetch sprite for this Pokémon
        const spriteUrl = await fetchSprite(currentPokemonName);
        if (!spriteUrl) {
          console.error('Sprite not found for', currentPokemonName);
        }
        // Analyze sprite to identify blank cells for the current grid size
        let blankCells = [];
        try {
          blankCells = await getBlankCellsForSprite(spriteUrl, difficulty.grid);
        } catch (err) {
          console.error('Failed to compute blank cells:', err);
          blankCells = [];
        }
        // Compute scoring parameters after removing blank cells
        const totalCells = difficulty.grid * difficulty.grid;
        maxTiles = totalCells - blankCells.length;
        if (maxTiles < 1) {
          // Ensure there is at least one tile to flip
          maxTiles = 1;
        }
        maxPoints = 1000 * difficulty.multiplier;
        scorePotential = maxPoints;
        // Set background image
        pokemonContainer.style.backgroundImage = `url('${spriteUrl}')`;
        // Build overlay grid
        overlayGrid.innerHTML = '';
        overlayGrid.style.gridTemplateColumns = `repeat(${difficulty.grid}, 1fr)`;
        overlayGrid.style.gridTemplateRows = `repeat(${difficulty.grid}, 1fr)`;
        // Create all cells (totalCells) but mark blank ones as revealed
        for (let i = 0; i < totalCells; i++) {
          const cell = document.createElement('div');
          cell.className = 'overlay-cell';
          // If this index is in the blankCells list, mark it as revealed so it doesn't count as a flip
          if (blankCells.includes(i)) {
            cell.classList.add('revealed');
          } else {
            cell.addEventListener('click', () => {
              if (cell.classList.contains('revealed')) return;
              revealCell(cell);
            });
          }
          overlayGrid.appendChild(cell);
        }
        updateScoreboard();
      }

      function revealCell(cell) {
        // Reveal this cell and increment flip count
        cell.classList.add('revealed');
        flippedCount++;
        // Enable guessing when at least one tile has been flipped
        if (flippedCount === 1) {
          // Keep maximum points on the first flip
          scorePotential = maxPoints;
        } else {
          // Calculate score reduction relative to the remaining available tiles (excluding the first tile)
          const remainingTiles = maxTiles - flippedCount;
          const denominator = maxTiles - 1;
          // Protect against division by zero
          const ratio = denominator > 0 ? remainingTiles / denominator : 0;
          scorePotential = Math.ceil(ratio * maxPoints);
          if (scorePotential < 1) scorePotential = 1;
        }
        updateScoreboard();
      }

      // Reveal all grid cells to show the entire image
      function revealAllTiles() {
        const cells = overlayGrid.querySelectorAll('.overlay-cell');
        cells.forEach(c => {
          c.classList.add('revealed');
        });
      }

      function updateScoreboard() {
        livesDisplay.textContent = `Lives: ${livesLeft}`;
        scoreDisplay.textContent = `Score: ${totalScore}`;
        progressDisplay.textContent = `${currentIndex + 1} / ${numImages}`;
      }

      function handleGuess() {
        // Normalise both guess and Pokémon name: remove spaces, hyphens, apostrophes
        // and other non-alphanumeric characters before comparing.  This allows
        // e.g. "mr mime", "mr-mime" or "mr'mime" to all match "mr-mime".
        const rawGuess = guessInput.value.trim().toLowerCase();
        const normalizedGuess = rawGuess.replace(/[^a-z0-9]/g, '');
        const normalizedAnswer = currentPokemonName.toLowerCase().replace(/[^a-z0-9]/g, '');
        // Do not allow guesses until at least one tile has been flipped
        if (flippedCount === 0) {
          messageDiv.style.color = '#d9534f';
          messageDiv.textContent = 'Flip at least one tile before guessing.';
          return;
        }
        if (!normalizedGuess) return;
        if (normalizedGuess === normalizedAnswer) {
          // Correct guess: reveal the entire image and award the current potential score
          revealAllTiles();
          messageDiv.style.color = '#28a745';
          messageDiv.textContent = 'Correct!';
          totalScore += scorePotential;
          correctCount++;
          updateScoreboard();
          // Move to next Pokémon after a short delay
          setTimeout(nextRound, 1000);
        } else {
          // Wrong guess
          livesLeft--;
          // Reduce potential score by 10% of the maximum score for this difficulty
          scorePotential = Math.max(1, scorePotential - Math.ceil(maxPoints * 0.1));
          messageDiv.style.color = '#d9534f';
          messageDiv.textContent = `Incorrect! Lives left: ${livesLeft}`;
          updateScoreboard();
          if (livesLeft <= 0) {
            // Out of lives: reveal image, no points awarded
            revealAllTiles();
            messageDiv.textContent = `No lives left! The correct answer was ${currentPokemonName}.`;
            setTimeout(nextRound, 1500);
          }
        }
      }

      async function nextRound() {
        currentIndex++;
        if (currentIndex >= numImages) {
          // Game over -> show summary
          showSummary();
        } else {
          await setupPokemonRound();
        }
      }

      function showSummary() {
        gameArea.style.display = 'none';
        summaryScreen.style.display = 'block';
        summaryText.textContent = `You guessed ${correctCount} out of ${numImages} Pokémon correctly and scored ${totalScore} points.`;
      }

      // Return to the start screen so the player can change generations or difficulty
      function backToSettings() {
        // Stop any ongoing round and show the start screen
        startScreen.style.display = 'block';
        gameArea.style.display = 'none';
        summaryScreen.style.display = 'none';
      }

      async function startGame() {
        // Read selected generations
        selectedGenerations = Array.from(generationOptions.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
        if (selectedGenerations.length === 0) {
          alert('Please select at least one generation.');
          return;
        }
        // Read difficulty
        const selectedDifficulty = document.querySelector('input[name="difficulty"]:checked');
        difficultyKey = selectedDifficulty ? selectedDifficulty.value : 'easy';
        // Read number of images
        const numInput = document.getElementById('num-images');
        const parsedNum = parseInt(numInput.value, 10);
        if (isNaN(parsedNum) || parsedNum < 1 || parsedNum > 99) {
          alert('Please enter a number of images between 1 and 99.');
          return;
        }
        numImages = parsedNum;

        // Build Pokémon pool
        try {
          const species = await buildPokemonPool(selectedGenerations);
          if (species.length === 0) {
            alert('No Pokémon species found for selected generations.');
            return;
          }
          // Shuffle and pick unique species if possible
          const shuffled = species.sort(() => 0.5 - Math.random());
          gameData = shuffled.slice(0, numImages);
        } catch (err) {
          console.error('Error building Pokémon pool:', err);
          alert('Failed to fetch Pokémon data. Please try again later.');
          return;
        }

        // Reset game state
        totalScore = 0;
        currentIndex = 0;
        correctCount = 0;
        summaryScreen.style.display = 'none';
        startScreen.style.display = 'none';
        gameArea.style.display = 'flex';

        // Setup first round
        await setupPokemonRound();
      }

      // Navigate back to the start screen for selecting generations and difficulty
      function backToSettings() {
        startScreen.style.display = 'block';
        gameArea.style.display = 'none';
        summaryScreen.style.display = 'none';
      }

      // Event listeners
      document.getElementById('start-button').addEventListener('click', startGame);
      guessButton.addEventListener('click', () => {
        handleGuess();
      });
      guessInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          handleGuess();
        }
      });
      settingsButton.addEventListener('click', backToSettings);
      settingsButton.addEventListener('click', backToSettings);
    })();
  </script>
</body>
</html>
